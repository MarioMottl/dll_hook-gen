// @generated by dll-hook-gen; DO NOT EDIT
#![allow(non_snake_case, non_camel_case_types)]

use once_cell::sync::OnceCell;
use libloading::Library;
use std::ffi::c_void;

static DLL: OnceCell<Library> = OnceCell::new();

fn dll() -> &'static Library {
    DLL.get_or_init(|| {
        Library::new("{{ dll_filename }}")
            .expect("failed to load original DLL")
    })
}

{% for func in exports %}
pub type {{ func.name }}Fn = unsafe extern "system" fn(
    {{ func.signature }}
) -> {{ func.ret }};

static {{ func.name }}_PTR: OnceCell<{{ func.name }}Fn> = OnceCell::new();

#[no_mangle]
pub unsafe extern "system" fn {{ func.name }}({{ func.signature }}) -> {{ func.ret }} {
    println!(">>> {{ func.name }} called");

    {% set sig_no_ret = func.signature | split(pat="->") | first %}
    let f = *{{ func.name }}_PTR.get_or_init(|| {
        let sym: *mut c_void = *dll()
            .get(concat!("{{ func.name }}\0").as_bytes())
            .expect("symbol missing");
        std::mem::transmute(sym)
    });

    // forward call with just the argument names
    f(
      {%- for param in sig_no_ret | split(pat=",") %}
        {{ (param | split(pat=":") | first | trim) }}{% if not loop.last %}, {% endif %}
      {%- endfor -%}
    )
}
{% endfor %}
